<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="CCMixset.html">
<link rel="next" href="CCHashSet.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="CCVector" rel="Chapter" href="CCVector.html">
<link title="CCHeap" rel="Chapter" href="CCHeap.html">
<link title="CCList" rel="Chapter" href="CCList.html">
<link title="CCOpt" rel="Chapter" href="CCOpt.html">
<link title="CCPair" rel="Chapter" href="CCPair.html">
<link title="CCFun" rel="Chapter" href="CCFun.html">
<link title="CCHash" rel="Chapter" href="CCHash.html">
<link title="CCInt" rel="Chapter" href="CCInt.html">
<link title="CCBool" rel="Chapter" href="CCBool.html">
<link title="CCFloat" rel="Chapter" href="CCFloat.html">
<link title="CCArray" rel="Chapter" href="CCArray.html">
<link title="CCRef" rel="Chapter" href="CCRef.html">
<link title="CCSet" rel="Chapter" href="CCSet.html">
<link title="CCOrd" rel="Chapter" href="CCOrd.html">
<link title="CCRandom" rel="Chapter" href="CCRandom.html">
<link title="CCString" rel="Chapter" href="CCString.html">
<link title="CCHashtbl" rel="Chapter" href="CCHashtbl.html">
<link title="CCMap" rel="Chapter" href="CCMap.html">
<link title="CCFormat" rel="Chapter" href="CCFormat.html">
<link title="CCIO" rel="Chapter" href="CCIO.html">
<link title="CCInt64" rel="Chapter" href="CCInt64.html">
<link title="CCChar" rel="Chapter" href="CCChar.html">
<link title="CCResult" rel="Chapter" href="CCResult.html">
<link title="CCParse" rel="Chapter" href="CCParse.html">
<link title="CCArray_slice" rel="Chapter" href="CCArray_slice.html">
<link title="CCListLabels" rel="Chapter" href="CCListLabels.html">
<link title="CCArrayLabels" rel="Chapter" href="CCArrayLabels.html">
<link title="Containers" rel="Chapter" href="Containers.html">
<link title="CCKTree" rel="Chapter" href="CCKTree.html">
<link title="CCKList" rel="Chapter" href="CCKList.html">
<link title="CCLazy_list" rel="Chapter" href="CCLazy_list.html">
<link title="CCMultiMap" rel="Chapter" href="CCMultiMap.html">
<link title="CCMultiSet" rel="Chapter" href="CCMultiSet.html">
<link title="CCTrie" rel="Chapter" href="CCTrie.html">
<link title="CCFlatHashtbl" rel="Chapter" href="CCFlatHashtbl.html">
<link title="CCCache" rel="Chapter" href="CCCache.html">
<link title="CCPersistentHashtbl" rel="Chapter" href="CCPersistentHashtbl.html">
<link title="CCDeque" rel="Chapter" href="CCDeque.html">
<link title="CCFQueue" rel="Chapter" href="CCFQueue.html">
<link title="CCBV" rel="Chapter" href="CCBV.html">
<link title="CCMixtbl" rel="Chapter" href="CCMixtbl.html">
<link title="CCMixmap" rel="Chapter" href="CCMixmap.html">
<link title="CCRingBuffer" rel="Chapter" href="CCRingBuffer.html">
<link title="CCIntMap" rel="Chapter" href="CCIntMap.html">
<link title="CCPersistentArray" rel="Chapter" href="CCPersistentArray.html">
<link title="CCMixset" rel="Chapter" href="CCMixset.html">
<link title="CCGraph" rel="Chapter" href="CCGraph.html">
<link title="CCHashSet" rel="Chapter" href="CCHashSet.html">
<link title="CCBitField" rel="Chapter" href="CCBitField.html">
<link title="CCHashTrie" rel="Chapter" href="CCHashTrie.html">
<link title="CCWBTree" rel="Chapter" href="CCWBTree.html">
<link title="CCRAL" rel="Chapter" href="CCRAL.html">
<link title="CCImmutArray" rel="Chapter" href="CCImmutArray.html">
<link title="CCHet" rel="Chapter" href="CCHet.html">
<link title="CCZipper" rel="Chapter" href="CCZipper.html">
<link title="CCPool" rel="Chapter" href="CCPool.html">
<link title="CCLock" rel="Chapter" href="CCLock.html">
<link title="CCSemaphore" rel="Chapter" href="CCSemaphore.html">
<link title="CCThread" rel="Chapter" href="CCThread.html">
<link title="CCBlockingQueue" rel="Chapter" href="CCBlockingQueue.html">
<link title="CCTimer" rel="Chapter" href="CCTimer.html">
<link title="CCUnix" rel="Chapter" href="CCUnix.html">
<link title="CCSexp" rel="Chapter" href="CCSexp.html">
<link title="CCSexp_lex" rel="Chapter" href="CCSexp_lex.html"><link title="Sequence Helpers" rel="Section" href="#2_SequenceHelpers">
<link title="Interfaces for graphs" rel="Section" href="#2_Interfacesforgraphs">
<link title="Bags of vertices" rel="Section" href="#2_Bagsofvertices">
<link title="Traversals" rel="Section" href="#2_Traversals">
<link title="Cycles" rel="Section" href="#2_Cycles">
<link title="Topological Sort" rel="Section" href="#2_TopologicalSort">
<link title="Lazy Spanning Tree" rel="Section" href="#2_LazySpanningTree">
<link title="Strongly Connected Components" rel="Section" href="#2_StronglyConnectedComponents">
<link title="Pretty printing in the DOT (graphviz) format" rel="Section" href="#2_PrettyprintingintheDOTgraphvizformat">
<link title="Mutable Graph" rel="Section" href="#2_MutableGraph">
<link title="Immutable Graph" rel="Section" href="#2_ImmutableGraph">
<link title="Misc" rel="Section" href="#2_Misc">
<title>Containers doc : CCGraph</title>
</head>
<body>
<div class="navbar"><a class="pre" href="CCMixset.html" title="CCMixset">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="CCHashSet.html" title="CCHashSet">Next</a>
</div>
<h1>Module <a href="type_CCGraph.html">CCGraph</a></h1>

<pre><span class="keyword">module</span> CCGraph: <code class="code"><span class="keyword">sig</span></code> <a href="CCGraph.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
<h1 id="1_SimpleGraphInterface">Simple Graph Interface</h1>
<p>

    A collections of algorithms on (mostly read-only) graph structures.
    The user provides her own graph structure as a <code class="code">(<span class="keywordsign">'</span>v, <span class="keywordsign">'</span>e) <span class="constructor">CCGraph</span>.t</code>,
    where <code class="code"><span class="keywordsign">'</span>v</code> is the type of vertices and <code class="code"><span class="keywordsign">'</span>e</code> the type of edges
    (for instance, <code class="code"><span class="keywordsign">'</span>e = (<span class="keywordsign">'</span>v * <span class="keywordsign">'</span>v)</code> is perfectly fine in many cases).
<p>

    Such a <code class="code">(<span class="keywordsign">'</span>v, <span class="keywordsign">'</span>e) <span class="constructor">CCGraph</span>.t</code> structure is a record containing
    three functions: two relate edges to their origin and destination,
    and one maps vertices to their outgoing edges.
    This abstract notion of graph makes it possible to run the algorithms
    on any user-specific type that happens to have a graph structure.
<p>

    Many graph algorithms here take a sequence of vertices as input.
    If the user only has a single vertex (e.g., for a topological sort
    from a given vertex), she can use <code class="code"><span class="constructor">Seq</span>.return x</code> to build a sequence
    of one element.
<p>

    <b>status: unstable</b><br>
<b>Since</b> 0.12<br>
</div>
<hr width="100%">
<br>
<h2 id="2_SequenceHelpers">Sequence Helpers</h2><br>

<pre><span id="TYPEsequence"><span class="keyword">type</span> <code class="type">'a</code> sequence</span> = <code class="type">('a -> unit) -> unit</code> </pre>
<div class="info ">
A sequence of items of type <code class="code"><span class="keywordsign">'</span>a</code>, possibly infinite<br>
</div>


<pre><span id="TYPEsequence_once"><span class="keyword">type</span> <code class="type">'a</code> sequence_once</span> = <code class="type">'a <a href="CCGraph.html#TYPEsequence">sequence</a></code> </pre>
<div class="info ">
Sequence that should be used only once<br>
</div>


<pre><span id="EXCEPTIONSequence_once"><span class="keyword">exception</span> Sequence_once</span></pre>
<div class="info ">
Raised when a sequence meant to be used once is used several times<br>
</div>

<pre><span class="keyword">module</span> <a href="CCGraph.Seq.html">Seq</a>: <code class="code"><span class="keyword">sig</span></code> <a href="CCGraph.Seq.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<h2 id="2_Interfacesforgraphs">Interfaces for graphs</h2>
<p>

    This interface is designed for oriented graphs with labels on edges<br>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">('v, 'e)</code> t</span> = <code class="type">'v -> ('e * 'v) <a href="CCGraph.html#TYPEsequence">sequence</a></code> </pre>
<div class="info ">
Directed graph with vertices of type <code class="code"><span class="keywordsign">'</span>v</code> and edges labeled with <code class="code">e'</code><br>
</div>


<pre><span id="TYPEgraph"><span class="keyword">type</span> <code class="type">('v, 'e)</code> graph</span> = <code class="type">('v, 'e) <a href="CCGraph.html#TYPEt">t</a></code> </pre>


<pre><span id="VALmake"><span class="keyword">val</span> make</span> : <code class="type">('v -> ('e * 'v) <a href="CCGraph.html#TYPEsequence">sequence</a>) -> ('v, 'e) <a href="CCGraph.html#TYPEt">t</a></code></pre><div class="info ">
Make a graph by providing the children function<br>
</div>

<pre><code><span id="TYPEtag_set"><span class="keyword">type</span> <code class="type">'v</code> tag_set</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtag_set.get_tag">get_tag</span>&nbsp;: <code class="type">'v -> bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtag_set.set_tag">set_tag</span>&nbsp;: <code class="type">'v -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Set tag for the given element<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<h2 id="2_Tags">Tags</h2>
<p>

    Mutable tags from values of type <code class="code"><span class="keywordsign">'</span>v</code> to tags of type <code class="code">bool</code><br>
</div>


<pre><code><span id="TYPEtable"><span class="keyword">type</span> <code class="type">('k, 'a)</code> table</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtable.mem">mem</span>&nbsp;: <code class="type">'k -> bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtable.find">find</span>&nbsp;: <code class="type">'k -> 'a</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<b>Raises</b> <code>Not_found</code> if element not added before<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTtable.add">add</span>&nbsp;: <code class="type">'k -> 'a -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Erases previous binding<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<h2 id="2_Table">Table</h2>
<p>

    Mutable table with keys <code class="code"><span class="keywordsign">'</span>k</code> and values <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>


<pre><span id="TYPEset"><span class="keyword">type</span> <code class="type">'a</code> set</span> = <code class="type">('a, unit) <a href="CCGraph.html#TYPEtable">table</a></code> </pre>
<div class="info ">
Mutable set<br>
</div>


<pre><span id="VALmk_table"><span class="keyword">val</span> mk_table</span> : <code class="type">?eq:('k -> 'k -> bool) -> ?hash:('k -> int) -> int -> ('k, 'a) <a href="CCGraph.html#TYPEtable">table</a></code></pre><div class="info ">
Default implementation for <a href="CCGraph.html#TYPEtable"><code class="code"><span class="constructor">CCGraph</span>.table</code></a>: a <code class="code"><span class="constructor">Hashtbl</span>.t</code><br>
</div>

<pre><span id="VALmk_map"><span class="keyword">val</span> mk_map</span> : <code class="type">?cmp:('k -> 'k -> int) -> unit -> ('k, 'a) <a href="CCGraph.html#TYPEtable">table</a></code></pre><div class="info ">
Use a <code class="code"><span class="constructor">Map</span>.<span class="constructor">S</span></code> underneath<br>
</div>
<br>
<h2 id="2_Bagsofvertices">Bags of vertices</h2><br>

<pre><code><span id="TYPEbag"><span class="keyword">type</span> <code class="type">'a</code> bag</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbag.push">push</span>&nbsp;: <code class="type">'a -> unit</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbag.is_empty">is_empty</span>&nbsp;: <code class="type">unit -> bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbag.pop">pop</span>&nbsp;: <code class="type">unit -> 'a</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
raises some exception is empty<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
Bag of elements of type <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>


<pre><span id="VALmk_queue"><span class="keyword">val</span> mk_queue</span> : <code class="type">unit -> 'a <a href="CCGraph.html#TYPEbag">bag</a></code></pre>
<pre><span id="VALmk_stack"><span class="keyword">val</span> mk_stack</span> : <code class="type">unit -> 'a <a href="CCGraph.html#TYPEbag">bag</a></code></pre>
<pre><span id="VALmk_heap"><span class="keyword">val</span> mk_heap</span> : <code class="type">leq:('a -> 'a -> bool) -> 'a <a href="CCGraph.html#TYPEbag">bag</a></code></pre><div class="info ">
<code class="code">mk_heap ~leq</code> makes a priority queue where <code class="code">leq x y = <span class="keyword">true</span></code> means that
    <code class="code">x</code> is smaller than <code class="code">y</code> and should be prioritary<br>
</div>
<br>
<h2 id="2_Traversals">Traversals</h2><br>

<pre><span class="keyword">module</span> <a href="CCGraph.Traverse.html">Traverse</a>: <code class="code"><span class="keyword">sig</span></code> <a href="CCGraph.Traverse.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<h2 id="2_Cycles">Cycles</h2><br>

<pre><span id="VALis_dag"><span class="keyword">val</span> is_dag</span> : <code class="type">?tbl:'v <a href="CCGraph.html#TYPEset">set</a> -><br>       graph:('v, 'a) <a href="CCGraph.html#TYPEt">t</a> -> 'v <a href="CCGraph.html#TYPEsequence">sequence</a> -> bool</code></pre><div class="info ">
<code class="code">is_dag ~graph vs</code> returns <code class="code"><span class="keyword">true</span></code> if the subset of <code class="code">graph</code> reachable
    from <code class="code">vs</code> is acyclic.<br>
<b>Since</b> 0.18<br>
</div>
<br>
<h2 id="2_TopologicalSort">Topological Sort</h2><br>

<pre><span id="EXCEPTIONHas_cycle"><span class="keyword">exception</span> Has_cycle</span></pre>

<pre><span id="VALtopo_sort"><span class="keyword">val</span> topo_sort</span> : <code class="type">?eq:('v -> 'v -> bool) -><br>       ?rev:bool -><br>       ?tbl:'v <a href="CCGraph.html#TYPEset">set</a> -><br>       graph:('v, 'e) <a href="CCGraph.html#TYPEt">t</a> -> 'v <a href="CCGraph.html#TYPEsequence">sequence</a> -> 'v list</code></pre><div class="info ">
<code class="code">topo_sort ~graph seq</code> returns a list of vertices <code class="code">l</code> where each
    element of <code class="code">l</code> is reachable from <code class="code">seq</code>.
    The list is sorted in a way such that if <code class="code">v <span class="keywordsign">-&gt;</span> v'</code> in the graph, then
    <code class="code">v</code> comes before <code class="code">v'</code> in the list (i.e. has a smaller index).
    Basically <code class="code">v <span class="keywordsign">-&gt;</span> v'</code> means that <code class="code">v</code> is smaller than <code class="code">v'</code>
    see <a href=" https://en.wikipedia.org/wiki/Topological_sorting"> wikipedia</a><br>
<b>Raises</b> <code>Has_cycle</code> if the graph is not a DAG<br>
</div>
<div class="param_info"><code class="code">eq</code> : equality predicate on vertices (default <code class="code">(=)</code>)</div>
<div class="param_info"><code class="code">rev</code> : if true, the dependency relation is inverted (<code class="code">v <span class="keywordsign">-&gt;</span> v'</code> means
      <code class="code">v'</code> occurs before <code class="code">v</code>)</div>

<pre><span id="VALtopo_sort_tag"><span class="keyword">val</span> topo_sort_tag</span> : <code class="type">?eq:('v -> 'v -> bool) -><br>       ?rev:bool -><br>       tags:'v <a href="CCGraph.html#TYPEtag_set">tag_set</a> -><br>       graph:('v, 'e) <a href="CCGraph.html#TYPEt">t</a> -> 'v <a href="CCGraph.html#TYPEsequence">sequence</a> -> 'v list</code></pre><div class="info ">
Same as <a href="CCGraph.html#VALtopo_sort"><code class="code"><span class="constructor">CCGraph</span>.topo_sort</code></a> but uses an explicit tag set<br>
</div>
<br>
<h2 id="2_LazySpanningTree">Lazy Spanning Tree</h2><br>

<pre><span class="keyword">module</span> <a href="CCGraph.Lazy_tree.html">Lazy_tree</a>: <code class="code"><span class="keyword">sig</span></code> <a href="CCGraph.Lazy_tree.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="VALspanning_tree"><span class="keyword">val</span> spanning_tree</span> : <code class="type">?tbl:'v <a href="CCGraph.html#TYPEset">set</a> -><br>       graph:('v, 'e) <a href="CCGraph.html#TYPEt">t</a> -> 'v -> ('v, 'e) <a href="CCGraph.Lazy_tree.html#TYPEt">Lazy_tree.t</a></code></pre><div class="info ">
<code class="code">spanning_tree ~graph v</code> computes a lazy spanning tree that has <code class="code">v</code>
    as a root. The table <code class="code">tbl</code> is used for the memoization part<br>
</div>

<pre><span id="VALspanning_tree_tag"><span class="keyword">val</span> spanning_tree_tag</span> : <code class="type">tags:'v <a href="CCGraph.html#TYPEtag_set">tag_set</a> -><br>       graph:('v, 'e) <a href="CCGraph.html#TYPEt">t</a> -> 'v -> ('v, 'e) <a href="CCGraph.Lazy_tree.html#TYPEt">Lazy_tree.t</a></code></pre><br>
<h2 id="2_StronglyConnectedComponents">Strongly Connected Components</h2><br>

<pre><span id="TYPEscc_state"><span class="keyword">type</span> <code class="type">'v</code> scc_state</span> </pre>
<div class="info ">
Hidden state for <a href="CCGraph.html#VALscc"><code class="code"><span class="constructor">CCGraph</span>.scc</code></a><br>
</div>


<pre><span id="VALscc"><span class="keyword">val</span> scc</span> : <code class="type">?tbl:('v, 'v <a href="CCGraph.html#TYPEscc_state">scc_state</a>) <a href="CCGraph.html#TYPEtable">table</a> -><br>       graph:('v, 'e) <a href="CCGraph.html#TYPEt">t</a> -><br>       'v <a href="CCGraph.html#TYPEsequence">sequence</a> -> 'v list <a href="CCGraph.html#TYPEsequence_once">sequence_once</a></code></pre><div class="info ">
Strongly connected components reachable from the given vertices.
    Each component is a list of vertices that are all mutually reachable
    in the graph.
    The components are explored in a topological order (if C1 and C2 are
    components, and C1 points to C2, then C2 will be yielded before C1).
    Uses <a href=" https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm"> Tarjan's algorithm</a><br>
<b>Raises</b> <code>Sequence_once</code> if the result is iterated on more than once.<br>
</div>
<div class="param_info"><code class="code">tbl</code> : table used to map nodes to some hidden state</div>
<br>
<h2 id="2_PrettyprintingintheDOTgraphvizformat">Pretty printing in the DOT (graphviz) format</h2>
<p>

    Example (print divisors from <code class="code">42</code>):
<p>

    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;<span class="keyword">open</span>&nbsp;<span class="constructor">CCGraph</span>&nbsp;<span class="keyword">in</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;<span class="keyword">open</span>&nbsp;<span class="constructor">Dot</span>&nbsp;<span class="keyword">in</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with_out&nbsp;<span class="string">"/tmp/truc.dot"</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="keyword">fun</span>&nbsp;out&nbsp;<span class="keywordsign">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pp&nbsp;~attrs_v:(<span class="keyword">fun</span>&nbsp;i&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;[<span class="keywordsign">`</span><span class="constructor">Label</span>&nbsp;(string_of_int&nbsp;i)])&nbsp;~graph:divisors_graph&nbsp;out&nbsp;42
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;</code></pre><br>

<pre><span class="keyword">module</span> <a href="CCGraph.Dot.html">Dot</a>: <code class="code"><span class="keyword">sig</span></code> <a href="CCGraph.Dot.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<h2 id="2_MutableGraph">Mutable Graph</h2><br>

<pre><code><span id="TYPEmut_graph"><span class="keyword">type</span> <code class="type">('v, 'e)</code> mut_graph</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTmut_graph.graph">graph</span>&nbsp;: <code class="type">('v, 'e) <a href="CCGraph.html#TYPEt">t</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTmut_graph.add_edge">add_edge</span>&nbsp;: <code class="type">'v -> 'e -> 'v -> unit</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTmut_graph.remove">remove</span>&nbsp;: <code class="type">'v -> unit</code>;</code></td>

</tr></table>
}



<pre><span id="VALmk_mut_tbl"><span class="keyword">val</span> mk_mut_tbl</span> : <code class="type">?eq:('v -> 'v -> bool) -><br>       ?hash:('v -> int) -> int -> ('v, 'a) <a href="CCGraph.html#TYPEmut_graph">mut_graph</a></code></pre><div class="info ">
Make a new mutable graph from a Hashtbl. Edges are labelled with type <code class="code"><span class="keywordsign">'</span>a</code><br>
</div>
<br>
<h2 id="2_ImmutableGraph">Immutable Graph</h2>
<p>

    A classic implementation of a graph structure on totally ordered vertices,
    with unlabelled edges. The graph allows to add and remove edges and vertices,
    and to iterate on edges and vertices.<br>

<pre><span class="keyword">module type</span> <a href="CCGraph.MAP.html">MAP</a> = <code class="code"><span class="keyword">sig</span></code> <a href="CCGraph.MAP.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span class="keyword">module</span> <a href="CCGraph.Map.html">Map</a> <code class="code">(</code><code class="code"><span class="constructor">O</span></code><code class="code"> : </code><code class="type">Map.OrderedType</code><code class="code">) </code>: <code class="type"><a href="CCGraph.MAP.html">MAP</a></code><code class="type">  with type vertex = O.t</code></pre><br>
<h2 id="2_Misc">Misc</h2><br>

<pre><span id="VALof_list"><span class="keyword">val</span> of_list</span> : <code class="type">?eq:('v -> 'v -> bool) -> ('v * 'v) list -> ('v, unit) <a href="CCGraph.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_list l</code> makes a graph from a list of pairs of vertices.
    Each pair <code class="code">(a,b)</code> is an edge from <code class="code">a</code> to <code class="code">b</code>.<br>
</div>
<div class="param_info"><code class="code">eq</code> : equality used to compare vertices</div>

<pre><span id="VALof_hashtbl"><span class="keyword">val</span> of_hashtbl</span> : <code class="type">('v, 'v list) Hashtbl.t -> ('v, unit) <a href="CCGraph.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_hashtbl tbl</code> makes a graph from a hashtable that maps vertices
    to lists of children<br>
</div>

<pre><span id="VALof_fun"><span class="keyword">val</span> of_fun</span> : <code class="type">('v -> 'v list) -> ('v, unit) <a href="CCGraph.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_fun f</code> makes a graph out of a function that maps a vertex to
    the list of its children. The function is assumed to be deterministic.<br>
</div>

<pre><span id="VALdivisors_graph"><span class="keyword">val</span> divisors_graph</span> : <code class="type">(int, unit) <a href="CCGraph.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">n</code> points to all its strict divisors<br>
</div>
</body></html>